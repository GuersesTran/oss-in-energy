from dataclasses import dataclass
from typing import Optional, List, Callable, Tuple
import validators
from datetime import date

# TODO: ist this a good approach?
# class Category(Enum):
#     MODELING
#     SIMULATION
#     INTERFACES
#     PLATFORM
#     FORECASTING
#     STATE_ESTIMATION
#     OPTIMIZATION
#     POWER_QUALITY
#     FIRMWARE
#     ALGORITHMS


@dataclass
class OpenSourceProject:
    """Class for keeping track of an item in inventory."""

    # mandatory
    name: str
    repository: str
    description: str

    # optional
    homepage: Optional[str]

    # auto generated if not given
    license_name: Optional[str]
    languages: Optional[List[str]]
    tags: Optional[List[str]]
    first_release: Optional[Tuple[date, str]]

    # auto generated
    # category: str
    last_update: str
    last_release: Optional[date]

    # Ideas:
    # Contributors
    # CI/Coverage

    @classmethod
    def from_dict(cls, d: dict) -> "OpenSourceProject":
        def get_dict_value(
            d: dict, key: str, validator: Callable[[str], bool] = None
        ) -> Optional[str]:
            if not key in d:
                return None
            val = d[key]
            if not val:
                return None
            if validator is not None:
                # TODO: maybe raise exception if value is invalid?
                if not validator(val):
                    return None
            return val

        # Mandatory
        name = get_dict_value(d, "name")
        assert isinstance(name, str), "Project needs to have a name!"

        repository = get_dict_value(d, "repository")
        assert isinstance(repository, str), "Project needs to have a valid url!"

        description = get_dict_value(d, "description")
        assert isinstance(description, str), "Project needs to have a proper description!"

        # Manual
        homepage = get_dict_value(d, "homepage", validators.url)

        # Semi autogenerated

        license_name = get_dict_value(d, "license")
        # TODO: Validate license against enum
        # TODO: get license from API

        first_release = get_dict_value(d, "first_release")

        languages = get_dict_value(d, "languages")
        # TODO: Convert to list
        # TODO: get languages from API

        tags = get_dict_value(d, "tags")
        # TODO: Convert to list
        # TODO: get languages from API

        # Autogenerated

        # TODO: generate from API
        last_update = None
        last_release = None

        return cls(
            name=name,
            repository=repository,
            description=description,
            homepage=homepage,
            license_name=license_name,
            languages=languages,
            tags=tags,
            # category=category,
            last_update=last_update,
            last_release=last_release,
            first_release=first_release,
        )

    @classmethod
    def list_headers(cls):
        return [
            "Project",
            "Repository URL",
            "Description",
            "Homepage",
            "License",
            "Languages",
            "Tags",
            # "Category",
            "Last Update",
            "Last Release",
            "First Release",
        ]

    def to_list(self) -> List[str]:
        def stringify(o):
            if o:
                return str(o)
            else:
                return ""

        return [
            self.name,
            f'<a href="{self.repository}">{self.repository}</a>',
            self.description,
            f'<a href="{self.homepage}">{self.homepage}</a>',
            stringify(self.license_name),
            stringify(self.languages),
            stringify(self.tags),
            # self.category,
            stringify(self.last_update),
            stringify(self.last_release),
            stringify(self.first_release),
        ]
